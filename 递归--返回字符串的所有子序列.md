/*
a b c
✅✅✅
❌❌❌

就是从a到c之间，要不要它的过程
所以 要 与 不要 就可以构成 二叉树了

*/

<img width="913" alt="image" src="https://github.com/zhenhaoshuai/SuanFaJinSai/assets/88430983/e35650da-84cb-44b7-8995-85da1f61cdf8">


``` 
 
/*

教训：   像这种一个序列上的，我们想把它转成 二叉树的话，都要给他 想左指针 和 右指针 的关系，如这题就给他了 一个 lpos 和 rpos

pos:当前字符在 字符串中的位置
boundary:就是这个字符的长度
*/
void subSequence2Solve(std::string &s, std::vector<std::string> &res, std::string& strTemp, int lpos, int rpos, int boundary) {

    if ((lpos > boundary) || (rpos > boundary))
    {
        res.push_back(strTemp);
        return;
    }
    
    if (lpos <= boundary)
    {
        //左的话就是不添值，所以无操作  左进行添加 -c
        // strTemp.push_back(“”);
        subSequence2Solve(s, res, strTemp, lpos + 1,lpos + 1, boundary);
    }

    if (rpos <= boundary)
    {
        strTemp.push_back(s[rpos]);//右进行添加 +c
        subSequence2Solve(s, res, strTemp,rpos + 1, rpos + 1, boundary);
    }
    if (strTemp != "")
    {
        strTemp.pop_back();
    }
}

std::vector<std::string> subSequence2(std::string s) {
    std::string str(s);
    std::vector<std::string> res;
    std::string resTemp;
    subSequence2Solve(str, res, resTemp,0, 0, str.size() - 1);
    std::sort(res.begin(),res.end());
    return res;
}
```

