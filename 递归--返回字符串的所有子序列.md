/*
a b c
✅✅✅
❌❌❌

就是从a到c之间，要不要它的过程
所以 要 与 不要 就可以构成 二叉树了

*/

<img width="913" alt="image" src="https://github.com/zhenhaoshuai/SuanFaJinSai/assets/88430983/e35650da-84cb-44b7-8995-85da1f61cdf8">


``` 
/*
                    “”
                -a         +a
            -b    +b    -b     +b
        -c   +c -c +c -c  +c -c  +c


教训：   像这种一个序列上的，我们想把它转成 二叉树的话，都要给他 想左指针 和 右指针 的关系，如这题就给他了 一个 lpos 和 rpos  ---》把一维变成了二维的了
            左子树为空----当前节点----右子树为空
pos:当前字符在 字符串中的位置
boundary:就是这个字符的长度
*/
void subSequence2Solve(std::string &s, std::vector<std::string> &res, std::string& strTemp, int lpos, int rpos, int boundary) {

    if ((lpos > boundary) || (rpos > boundary))
    {
        res.push_back(strTemp);
        return;
    }
    
    if (rpos <= boundary) //由于后面要排序我们就把位置提前
    {
        strTemp.push_back(s[rpos]);//右进行添加 +c
        subSequence2Solve(s, res, strTemp,rpos + 1, rpos + 1, boundary);
    }
    if (strTemp != "")
    {
        strTemp.pop_back();
    }

    if (lpos <= boundary)
    {
        //左的话就是不添值，所以无操作  左进行添加 -c
        // strTemp.push_back(“”);
        subSequence2Solve(s, res, strTemp, lpos + 1,lpos + 1, boundary);
    }
}

std::vector<std::string> subSequence2(std::string s) {
    std::string str(s);
    std::vector<std::string> res;
    std::string resTemp;
    subSequence2Solve(str, res, resTemp,0, 0, str.size() - 1);
    std::sort(res.begin(),res.end());
// 使用unique函数去除重复元素，unique函数并不会真正删除元素，
    // 它会把重复的元素放到vector的末端，并返回新的逻辑结尾的迭代器
    auto last = std::unique(res.begin(), res.end());
 
    // 通过erase函数删除重复元素后的多余元素
    res.erase(last, res.end());

    return res;
}

```

